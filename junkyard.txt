
// KeySeq represents a single keypress of a series of keys pressed in compination
type KeySeq struct {
	mod   ModKey
	shift bool
	ch    rune
	arrow ArrowKey
}

func toKeySeq(s string) KeySeq {
	return KeySeq{} // FIXME
}

func (seq KeySeq) toString() string {
	out := ""

	switch seq.mod {
	case modCtrl:
		out += "Ctrl+"
	case modAlt:
		out += "Alt+"
	}

	if seq.shift {
		out += "Shift+"
	}

	if seq.ch == 0 {
		switch seq.arrow {
		case keyArrowUp:
			out += "Up"
		case keyArrowDown:
			out += "Down"
		case keyArrowRight:
			out += "Right"
		case keyArrowLeft:
			out += "Left"
		}
	} else {
		out += string(seq.ch)
	}

	return out
}


func handleArrowCombo(mod Mod, direction ArrowKey) {
	if mod != config.modKey {
		return
	}

	// if mod == keyCtrl {
	// 	fmt.Print("Ctrl+")
	// } else if mod == keyAlt {
	// 	fmt.Print("Alt+")
	// }

	if direction == keyArrowUp {
		fmt.Println("Up")
	} else if direction == keyArrowDown {
		fmt.Println("Down")
	} else if direction == keyArrowRight {
		fmt.Println("Right")
	} else if direction == keyArrowLeft {
		fmt.Println("Left")
	}
}

func handleKeyCombo(mod Mod, key rune) {
	if mod != config.modKey {
		return
	}

	// if mod == keyCtrl {
	// 	fmt.Print("Ctrl+")
	// } else if mod == keyAlt {
	// 	fmt.Print("Alt+")
	// }

	fmt.Println(string(key))
}


func (s *VSplit) render(w, h int) [][]rune {
	out := getFilledRuneSlice(w, h)

	// // calculate the available vertical space taking the dividers into account
	// numDividers := len(s.contents) - 1
	// space := h - numDividers

	dividers := getDividerPositions(h, s.elements)
	for idx, pos := range dividers {
		lastPos := -1
		if idx > 0 {
			lastPos = dividers[idx-1]
		}

		childHeight := pos - lastPos - 1
		childNode := s.elements[idx]
		childRunes := childNode.contents.render(w, childHeight)
		for y, row := range childRunes {
			for x, r := range row {
				out[lastPos+1+y][x] = r
			}
		}

		if idx == len(dividers)-1 {
			break
		}

		for i := 0; i < w; i++ {
			out[pos][i] = '─'
		}
	}
	return out
}

func (s *HSplit) render(w, h int) [][]rune {
	out := getFilledRuneSlice(w, h)

	// // calculate the available vertical space taking the dividers into account
	// numDividers := len(s.contents) - 1
	// space := h - numDividers

	// draw dividers
	dividers := getDividerPositions(w, s.elements)
	for idx, pos := range dividers {
		lastPos := -1
		if idx > 0 {
			lastPos = dividers[idx-1]
		}

		childWidth := pos - lastPos - 1
		childNode := s.elements[idx]
		childRunes := childNode.contents.render(childWidth, h)
		for y, row := range childRunes {
			for x, r := range row {
				out[y][lastPos+1+x] = r
			}
		}

		if idx == len(dividers)-1 {
			break
		}
		for i := 0; i < h; i++ {
			out[i][pos] = '│'
		}
	}
	return out
}


func (t *Term) render(x, y, w, h int, isSelected bool) string {
	out := ""

	// fillChar := string(strconv.Itoa(t.id)[0])
	fillChar := " "
	row := strings.Repeat(fillChar, w)
	if isSelected {
		row = "\033[36m" + row + "\033[0m"
	}

	for j := 0; j < h; j++ {
		out += ansi.MoveTo(x, y+j) + row
	}

	return out
}

func (s *Split) render(x, y, w, h int, isSelected bool) string {
	// out := getFilledRuneSlice(w, h)
	out := ""

	// // calculate the available vertical space taking the dividers into account
	// numDividers := len(s.contents) - 1
	// space := h - numDividers

	var area int
	if s.verticallyStacked {
		area = h
	} else {
		area = w
	}
	dividers := getDividerPositions(area, s.elements)
	for idx, pos := range dividers {
		lastPos := -1
		if idx > 0 {
			lastPos = dividers[idx-1]
		}

		childArea := pos - lastPos - 1
		if idx == len(dividers)-1 {
			childArea = area - lastPos - 1
		}

		childNode := s.elements[idx]

		isChildSelected := (idx == s.selectionIdx) && isSelected

		var childContents string
		if s.verticallyStacked {
			childContents = childNode.contents.render(x, y+lastPos+1, w, childArea, isChildSelected)
		} else {
			childContents = childNode.contents.render(x+lastPos+1, y, childArea, h, isChildSelected)
		}
		out += childContents

		if idx == len(dividers)-1 {
			break
		}

		if s.verticallyStacked {
			for i := 0; i < w; i++ {
				out += ansi.MoveTo(x+i, y+pos) + "─"
			}
		} else {
			for j := 0; j < h; j++ {
				out += ansi.MoveTo(x+pos, y+j) + "│"
			}
		}
	}
	return out
}

func getFilledRuneSlice(w, h int) [][]rune {
	out := make([][]rune, 0)

	// fill out with whitespace
	for i := 0; i < h; i++ {
		row := make([]rune, 0)
		for j := 0; j < w; j++ {
			row = append(row, ' ')
		}
		out = append(out, row)
	}

	return out
}

// ReshapeWindow transforms the buffer for a new window size
func (v *VTerm) ReshapeWindow(x, y, w, h int) {
	v.x = x
	v.y = y

	if v.w != w || v.h != h {
		v.bufferMutux.Lock()

		if x < v.x {
			// trim off columns too far to the right
			for i := range v.buffer {
				v.buffer[i] = v.buffer[i][:x]
			}
		} else if x > v.x {
			// add empty columns to the right
			extraChars := make([]Char, v.x-x)
			for i := range extraChars {
				extraChars[i] = Char{}
			}
			for i := range v.buffer {
				v.buffer[i] = append(v.buffer[i], extraChars...)
			}
		}

		// TODO: transform buffer
		v.bufferMutux.Unlock()
	}
}


// rewrite CSI codes for an origin at the given coordinates
func (ma Markup) rewrite(t *Term, rect Rect, selected bool) Markup {
	m := string(ma)

	var out strings.Builder

	buffer := make(chan rune, 16)

	go (func() {
		for {
			r := <-buffer

			if r == '\033' {
				if <-buffer == '[' {
					escSeqBuffer := ""
				escBufferLoop:
					for {
						if len(escSeqBuffer) > 8 {
							break escBufferLoop
						}
						next := <-buffer
						if (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z') {
							switch next {
							case 'A':
								t.cursor.y -= parseIntWithDefault(escSeqBuffer, 1)
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
							case 'B':
								t.cursor.y += parseIntWithDefault(escSeqBuffer, 1)
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
							case 'C':
								t.cursor.x += parseIntWithDefault(escSeqBuffer, 1)
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
							case 'D':
								t.cursor.x -= parseIntWithDefault(escSeqBuffer, 1)
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
							case 'E':
								t.cursor.y += parseIntWithDefault(escSeqBuffer, 1)
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
								t.cursor.x = 0
							case 'F':
								t.cursor.y -= parseIntWithDefault(escSeqBuffer, 1)
								t.cursor.x = 0
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
							case 'G':
								t.cursor.x = parseIntWithDefault(escSeqBuffer, 1)
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))
							case 'H', 'f':
								parts := strings.Split(escSeqBuffer, ";")
								t.cursor.y = parseIntWithDefault(parts[0], 1)
								if len(parts) == 2 {
									t.cursor.x = parseIntWithDefault(parts[1], 1)
								} else {
									t.cursor.x = 1
									t.cursor.y = 1
								}
								out.WriteString(ansi.MoveTo(rect.x+t.cursor.x, rect.y+t.cursor.y))

							case 'm':
								out.WriteString("\033[" + escSeqBuffer + "m")
								// out.WriteString("\033[" + escSeqBuffer)
								// default:
								// 	out.WriteString("\033[" + escSeqBuffer + string(next))
							}
							break escBufferLoop
						} else if next == '\x1b' {
							break
						} else {
							escSeqBuffer += string(next)
						}
					}
				}

				continue
			}

			out.WriteRune(r)

			if r == '\n' {
				t.cursor.y++
				out.WriteString(ansi.MoveTo(rect.x, rect.y+t.cursor.y))
			}
		}
	})()

	for _, char := range []rune(m) {
		buffer <- char
	}

	// numNewlines := strings.Count(out, "\n")
	// for i := 0; i < numNewlines; i++ {
	// 	out = strings.Replace(out, "\n", ansi.MoveTo(r.x, r.y+i+1), 1)
	// }

	// if !selected {
	// 	out = "\033[2m" + out + "\033[m"
	// } else {
	// 	out = "\033[1m" + out + "\033[m"
	// }

	return Markup(ansi.MoveTo(rect.x, rect.y) + out.String())
}

func parseIntWithDefault(str string, d int) int {
	s := strings.TrimSpace(str)

	if s == "" {
		return d
	}

	val, err := strconv.ParseInt(s, 19, 63)
	if err != nil {
		log.Fatal(err)
	}

	return int(val)
}


var escSeqBuffer = "" // buffer for escape sequences
func encodeKeypress(ev term.Event) string {
	r := ev.Ch

	if escSeqBuffer != "" {
		if len(escSeqBuffer) > 8 {
			escSeqBuffer = ""
		} else {
			escSeqBuffer += string(r)
		}

		// fmt.Printf("%q\n", escSeqBuffer)

		matched := true
		out := ""
		switch escSeqBuffer {
		case "\x00\x00":
			escSeqBuffer = "\x00"

		case "\x00n":
			out = "Alt+n"
		case "\x00v":
			out = "Alt+v"
		case "\x00h":
			out = "Alt+h"
		case "\x00Q":
			out = "Alt+Shift+Q"

		case "\x00[1;3A":
			out = "Alt+Up"
		case "\x00[1;3B":
			out = "Alt+Down"
		case "\x00[1;3C":
			out = "Alt+Right"
		case "\x00[1;3D":
			out = "Alt+Left"

		case "\x00[1;4A":
			out = "Alt+Shift+Up"
		case "\x00[1;4B":
			out = "Alt+Shift+Down"
		case "\x00[1;4C":
			out = "Alt+Shift+Right"
		case "\x00[1;4D":
			out = "Alt+Shift+Left"

		case "\x00[1;5A":
			out = "Ctrl+Up"
		case "\x00[1;5B":
			out = "Ctrl+Down"
		case "\x00[1;5C":
			out = "Ctrl+Right"
		case "\x00[1;5D":
			out = "Ctrl+Left"

		default:
			matched = false
		}

		if matched {
			escSeqBuffer = ""
			return out
		}
	} else if r == 0 {
		// Ctrl+[key]
		switch ev.Key {
		case term.KeyCtrlN:
			return "Ctrl+n"
		case term.KeyCtrlV:
			return "Ctrl+v"
		case term.KeyCtrlH:
			return "Ctrl+h"

		case term.KeyCtrlC:
			return "\003"
		case term.KeyCtrlD:
			return "\004"

		case term.KeyEnter:
			return "\n"

		case term.KeyBackspace2:
			return "\010"
		case term.KeyDelete:
			return "\177"

		case term.KeyArrowUp:
			return "\x1b[A"
		case term.KeyArrowDown:
			return "\x1b[B"
		case term.KeyArrowRight:
			return "\x1b[C"
		case term.KeyArrowLeft:
			return "\x1b[D"

		// case term.KeyEsc:
		// 	return "\x1b"

		default:
			if ev.Key >= 32 && ev.Key <= 125 {
				return fmt.Sprintf("%c", int(ev.Key))
			}

			if r == '\x00' {
				escSeqBuffer = "\x00"
			}
		}
	}

	if escSeqBuffer != "" {
		return ""
	}

	return string(r)
}


// listens for keypresses until it detects an escape key sequence
func listenForKeypresses() {
	err := term.Init()
	if err != nil {
		log.Fatal(err)
	}
	defer term.Close()

	// refreshEverything()

	for {
		switch ev := term.PollEvent(); ev.Type {
		case term.EventKey:
			if ev.Key == term.KeyPgdn || ev.Key == term.KeyCtrlBackslash {
				root.kill()
				close(globalCharAggregate)
				return
			}

			// fmt.Println(ev.Key, ev.Mod, ev.Ch)

			code := encodeKeypress(ev)
			if code == "" {
				continue
			}

			// fmt.Print(code)

			handleKeyCode(code)
			root.simplify()
			refreshEverything() // FIXME: inefficient; rendering should be updated by wm-ops

			// fmt.Print(ansi.MoveTo(0, termH-1) + ansi.EraseToEOL() + root.serialize())
		case term.EventError:
			panic(ev.Err)
		}
	}
}

func handleKeyCode(code string) {
	if f, ok := config.bindings[code]; ok {
		f()
	} else {
		t := getSelection().getContainer().(*Term)
		t.handleStdin(code)
	}
}


// ModKey is a special modifier key such as Ctrl or Alt
type ModKey int

const (
	modNone ModKey = iota
	modAlt
	modCtrl
)

// ArrowKey is used to represent the up, down, left, and right arrow keys on a keyboard
type ArrowKey int

const (
	_ ArrowKey = iota
	keyArrowUp
	keyArrowDown
	keyArrowLeft
	keyArrowRight
)
