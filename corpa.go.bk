package main

// Config stores all user configuration values
type Config struct {
	statusBar bool
	bindings  map[string]string
}

var config = Config{
	statusBar: false,
	bindings: map[string]string{
		"Alt+N": "newWindow",

		"Alt+Shift+Up":    "moveWindow(Up)",
		"Alt+Shift+Down":  "moveWindow(Down)",
		"Alt+Shift+Left":  "moveWindow(Left)",
		"Alt+Shift+Right": "moveWindow(Right)",

		"Alt+Shift+I": "moveWindow(Up)",
		"Alt+Shift+K": "moveWindow(Down)",
		"Alt+Shift+J": "moveWindow(Left)",
		"Alt+Shift+L": "moveWindow(Right)",

		"Alt+Up":    "moveSelection(Up)",
		"Alt+Down":  "moveSelection(Down)",
		"Alt+Left":  "moveSelection(Left)",
		"Alt+Right": "moveSelection(Right)",

		"Alt+I": "moveSelection(Up)",
		"Alt+K": "moveSelection(Down)",
		"Alt+J": "moveSelection(Left)",
		"Alt+L": "moveSelection(Right)",

		"Alt+Shift+Q": "killWindow",
	},
}
package main

import (
	"fmt"
	"strings"
	"time"

	"github.com/aaronduino/i3-tmux/render"
)

// Rect is a rectangle with an origin x, origin y, width, and height
type Rect struct {
	x, y, w, h int
}

var termW, termH int

var renderer *render.Renderer

var startTime int64

// var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func main() {
	// needsShutdown := make(chan bool, 2)

	// flag.Parse()
	// if *cpuprofile != "" {
	// 	f, err := os.Create(*cpuprofile)
	// 	if err != nil {
	// 		log.Fatal(err)
	// 	}
	// 	pprof.StartCPUProfile(f)
	// 	defer pprof.StopCPUProfile()
	// }

	startTime = time.Now().UnixNano()

	termW, termH, _ = getTermSize()

	renderer = render.NewRenderer()
	renderer.Resize(termW, termH)
	go renderer.ListenToQueue()

	root = Split{
		verticallyStacked: false,
		selectionIdx:      0,
		elements: []Node{
			Node{
				size:     1,
				contents: newTerm(true),
			},
		}}
	defer root.kill()

	var h int
	if config.statusBar {
		h = termH - 1
	} else {
		h = termH
	}

	root.setRenderRect(0, 0, termW, h)

	// <-needsShutdown

	// fmt.Println("\033[2JHUJhsjgawhdjhgjgahsdjhggasd")

	// if config.statusBar {
	// 	debug(root.serialize())
	// }

	// ticker := time.NewTicker(time.Second / 30)
	// defer ticker.Stop()
	// go (func() {
	// 	for range ticker.C {
	// 		// for _, pane := range getPanes() {
	// 		// 	if pane.vterm.NeedsRedraw {
	// 		// 		pane.vterm.RedrawWindow()
	// 		// 	}
	// 		// }
	// 		// renderer.Refresh()

	// 		t := getSelection().getContainer().(*Pane)
	// 		t.vterm.RefreshCursor()
	// 	}
	// })()

	// keypress.Listen(func(name string, raw []byte) {
	// 	// fmt.Println(name, raw)

	// 	switch name {
	// 	case "Scroll Up":
	// 		t := getSelection().getContainer().(*Pane)
	// 		t.vterm.ScrollbackDown()
	// 	case "Scroll Down":
	// 		t := getSelection().getContainer().(*Pane)
	// 		t.vterm.ScrollbackUp()
	// 	default:
	// 		if operationCode, ok := config.bindings[name]; ok {
	// 			executeOperationCode(operationCode)
	// 			root.simplify()

	// 			root.refreshRenderRect()
	// 		} else {
	// 			t := getSelection().getContainer().(*Pane)

}

var shutdown chan bool

func executeOperationCode(s string) {
	sections := strings.Split(s, "(")

	funcName := sections[0]

	var parametersText string
	if len(sections) < 2 {
		parametersText = ""
	} else {
		parametersText = strings.TrimRight(sections[1], ")")
	}
	params := strings.Split(parametersText, ",")
	for idx, param := range params {
		params[idx] = strings.TrimSpace(param)
	}

	switch funcName {
	case "newWindow":
		newWindow()
	case "moveWindow":
		d := getDirectionFromString(params[0])
		moveWindow(d)
	case "moveSelection":
		d := getDirectionFromString(params[0])
		moveSelection(d)
	case "killWindow":
		killWindow()
	default:
		panic(funcName)
	}
}

func getDirectionFromString(s string) Direction {
	switch s {
	case "Up":
		return Up
	case "Down":
		return Down
	case "Left":
		return Left
	case "Right":
		return Right
	default:
		panic(fmt.Errorf("invalid direction: %v", s))
	}
}

// func debug(s string) {
// 	for i := 0; i < termW; i++ {
// 		r := ' '
// 		if i < len(s) {
// 			r = rune(s[i])
// 		}

// 		globalCharAggregate <- vterm.Char{
// 			Rune: r,
// 			Cursor: cursor.Cursor{
// 				X: i,
// 				Y: termH - 1,
// 				Bg: cursor.Color{
// 					ColorMode: cursor.ColorBit3Bright,
// 					Code:      2,
// 				},
// 				Fg: cursor.Color{
// 					ColorMode: cursor.ColorBit3Normal,
// 					Code:      0,
// 				},
// 			},
// 		}
// 	}
// }
package main

import (
	"fmt"
	"math/rand"

	"github.com/aaronduino/i3-tmux/render"
	"github.com/aaronduino/i3-tmux/vterm"
)

// A Pane is a tiling unit representing a terminal
type Pane struct {
	id int

	selected bool

	renderRect Rect

	vterm *vterm.VTerm
	shell Shell
}

func newTerm(selected bool) *Pane {
	stdout := make(chan rune, 320)
	shell := newShell(stdout)

	vtermOut := make(chan render.PositionedChar, 3200)

	t := &Pane{
		id:       rand.Intn(10),
		selected: selected,

		shell: shell,
	}

	parentSetCursor := func(x, y int) {
		if t.selected {
			renderer.SetCursor(x+t.renderRect.x, y+t.renderRect.y)
		}
	}

	vt := vterm.NewVTerm(renderer, parentSetCursor, stdout, vtermOut)
	go vt.ProcessStream()

	t.vterm = vt

	transformChars := func() {
		for {
			char := <-vtermOut
			if char.Cursor.X > t.renderRect.w-1 {
				continue
			}
			if char.Cursor.Y > t.renderRect.h-1 {
				continue
			}
			char.Cursor.X += t.renderRect.x
			char.Cursor.Y += t.renderRect.y
			// renderer.RenderQueue <- char
			renderer.HandleCh(char)
		}
	}

	go transformChars()

	return t
}

func (t *Pane) kill() {
	t.vterm.Kill()
	t.shell.Kill()
}

func (t *Pane) serialize() string {
	return fmt.Sprintf("Term")
}

func (t *Pane) setRenderRect(x, y, w, h int) {
	// r := t.renderRect
	// if x == r.x && y == r.y && w == r.w && h == r.h {
	// 	return
	// }

	t.renderRect = Rect{x, y, w, h}

	t.vterm.Reshape(w, h)
	t.vterm.RedrawWindow()
	// renderer.Refresh()

	t.shell.resize(w, h)

	t.softRefresh()
}

func (t *Pane) softRefresh() {
	if t.selected {
		drawSelectionBorder(t.renderRect)
		// t.win.Box(gc.ACS_VLINE, gc.ACS_HLINE)
	}
}
package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"syscall"
	"time"

	"github.com/kr/pty"
)

// Shell manages spawning, killing, and sending data to/from a shell subprocess (e.g. bash, sh, zsh)
type Shell struct {
	stdout chan<- rune
	ptmx   *os.File
	cmd    *exec.Cmd
}

func newShell(stdout chan<- rune) Shell {
	cmd := exec.Command("bash", "/home/ajanse/Playground/i3-tmux/test.sh")
	// cmd := exec.Command("zsh")

	ptmx, err := pty.Start(cmd)
	if err != nil {
		log.Fatal(err)
	}

	// feed ptmx output to stdout channel
	go (func() {
		defer func() {
			if r := recover(); r != nil {
				if r.(error).Error() != "send on closed channel" {
					panic(r)
				}
			}
		}()

		defer func() {
			nowTime := time.Now().UnixNano()
			fmt.Fprint(os.Stderr, (nowTime-startTime)/1000000)
			// needsShutdown <- true
			// panic("bye")
		}()

		for {
			bs := make([]byte, 1000)
			_, err := ptmx.Read(bs)
			if err != nil {
				if err.Error() == "read /dev/ptmx: input/output error" {
					break
				} else {
					panic(err)
				}
			}
			for _, b := range bs {
				if b == '\x60' {
					return
				}
				stdout <- rune(b)
			}
		}
	})()

	return Shell{
		stdout: stdout,
		ptmx:   ptmx,
		cmd:    cmd,
	}
}

// Kill safely shuts down the shell, closing stdout
func (s *Shell) Kill() {
	close(s.stdout)

	err := s.ptmx.Close()
	if err != nil {
		log.Fatal("failed to close ptmx", err)
	}

	err = s.cmd.Process.Kill()
	if err != nil {
		log.Fatal("failed to kill term process", err)
	}
}

func (s *Shell) handleStdin(data string) {
	_, err := s.ptmx.Write([]byte(data))
	if err != nil {
		log.Fatal(err)
	}
}

func (s *Shell) resize(w, h int) {
	// Handle pty size.
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGWINCH)
	go func() {
		for range ch {
			err := pty.Setsize(s.ptmx, &pty.Winsize{
				Rows: uint16(h), Cols: uint16(w),
				X: 16 * uint16(w), Y: 16 * uint16(h),
			})
			if err != nil {
				log.Fatal(err)
			}
		}
	}()
	ch <- syscall.SIGWINCH // Initial resize.
}
package main

import (
	"fmt"
)

// A Split splits a region of the screen into a areas reserved for multiple child nodes
type Split struct {
	elements          []Node
	selectionIdx      int
	verticallyStacked bool

	renderRect Rect
}

func (s *Split) serialize() string {
	var out string
	if s.verticallyStacked {
		out = "VSplit"
	} else {
		out = "HSplit"
	}

	out += fmt.Sprintf("[%d]", s.selectionIdx)

	out += "("
	for _, e := range s.elements {
		out += e.contents.serialize() + ", "
	}
	out += ")"

	return out
}

// setRenderRect updates the Split's renderRect cache after which it calls refreshRenderRect
// this for when a split is reshaped
func (s *Split) setRenderRect(x, y, w, h int) {
	s.renderRect = Rect{x, y, w, h}

	// // clear the relevant area of the screen
	// for j := 0; j < h; j++ {
	// 	for i := 0; i < w; i++ {
	// 		globalCharAggregate <- vterm.Char{
	// 			Rune:   '~',
	// 			Cursor: cursor.Cursor{X: x + i, Y: y + j},
	// 		}
	// 	}
	// }

	s.refreshRenderRect()
}

// refreshRenderRect recalculates the coordinates of a Split's elements and calls setRenderRect on each of its children
// this is for when one or more of a split's children are reshaped
func (s *Split) refreshRenderRect() {
	x := s.renderRect.x
	y := s.renderRect.y
	w := s.renderRect.w
	h := s.renderRect.h

	// s.redrawLines()

	var area int
	if s.verticallyStacked {
		area = h
	} else {
		area = w
	}
	dividers := getDividerPositions(area, s.elements)
	if len(s.elements) == 1 {
		dividers = []int{area}
	}
	for idx, pos := range dividers {
		lastPos := -1
		if idx > 0 {
			lastPos = dividers[idx-1]
		}

		childArea := pos - lastPos - 1
		if idx == len(dividers)-1 && idx != 0 {
			childArea = area - lastPos - 1
		}

		childNode := s.elements[idx]

		if s.verticallyStacked {
			childNode.contents.setRenderRect(x, y+lastPos+1, w, childArea)
		} else {
			childNode.contents.setRenderRect(x+lastPos+1, y, childArea, h)
		}
	}
}

// func (s *Split) redrawLines() {
// 	// x := s.renderRect.x
// 	// y := s.renderRect.y
// 	w := s.renderRect.w
// 	h := s.renderRect.h

// 	var area int
// 	if s.verticallyStacked {
// 		area = h
// 	} else {
// 		area = w
// 	}
// 	dividers := getDividerPositions(area, s.elements)
// 	for idx, _ := range dividers {
// 		if idx == len(dividers)-1 {
// 			break
// 		}

// 		if s.verticallyStacked {
// 			s.elements[idx].contents
// 		} else {

// 		}

// 		// if s.verticallyStacked {
// 		// 	for i := 0; i < w; i++ {
// 		// 		globalCharAggregate <- vterm.Char{
// 		// 			Rune:   '─',
// 		// 			Cursor: cursor.Cursor{X: x + i, Y: y + pos},
// 		// 		}
// 		// 	}
// 		// } else {
// 		// 	for j := 0; j < h; j++ {
// 		// 		globalCharAggregate <- vterm.Char{
// 		// 			Rune:   '│',
// 		// 			Cursor: cursor.Cursor{X: x + pos, Y: y + j},
// 		// 		}
// 		// 	}
// 		// }
// 	}
// }

func getDividerPositions(area int, contents []Node) []int {
	var dividerPositions []int
	for idx, node := range contents {
		var lastPos int
		if idx == 0 {
			lastPos = 0
		} else {
			lastPos = dividerPositions[idx-1]
		}
		pos := lastPos + int(node.size*float32(area))
		dividerPositions = append(dividerPositions, pos)
	}
	return dividerPositions
}
package main

// A Node represents a single pane of a split, having a size (relative to a total 1.0) and renderable contents
type Node struct {
	size     float32
	contents Container
}

// A Container is a renderable, debuggable, and killable unit of the window tree
type Container interface {
	setRenderRect(x, y, w, h int)
	serialize() string
	kill()
}

var root Split
package main

import (
	"os"
	"os/exec"
	"strconv"
	"strings"

	"github.com/aaronduino/i3-tmux/render"
)

func drawSelectionBorder(r Rect) {
	leftBorder := r.x > 0
	rightBorder := r.x+r.w+1 < termW
	topBorder := r.y > 0
	bottomBorder := r.y+r.h+1 < termH

	style := render.Style{
		Fg: render.Color{
			ColorMode: render.ColorBit3Normal,
			Code:      6,
		},
	}

	// draw lines
	if leftBorder {
		for i := 0; i <= r.h; i++ {
			// stdscr.MoveAddChar(r.y+i, r.x-1, gc.ACS_VLINE)
			renderer.RenderQueue <- render.PositionedChar{
				Rune: '│',
				Cursor: render.Cursor{
					X:     r.x - 1,
					Y:     r.y + i,
					Style: style,
				},
			}
		}
	}
	if rightBorder {
		for i := 0; i <= r.h; i++ {
			// stdscr.MoveAddChar(r.y+i, r.x+r.w, gc.ACS_VLINE)
			renderer.RenderQueue <- render.PositionedChar{
				Rune: '│',
				Cursor: render.Cursor{
					X:     r.x + r.w,
					Y:     r.y + i,
					Style: style,
				},
			}
		}
	}
	if topBorder {
		for i := 0; i <= r.w; i++ {
			// stdscr.MoveAddChar(r.y-1, r.x+i, gc.ACS_HLINE)
			renderer.RenderQueue <- render.PositionedChar{
				Rune: '─',
				Cursor: render.Cursor{
					X:     r.x + i,
					Y:     r.y - 1,
					Style: style,
				},
			}
		}
	}
	if bottomBorder {
		for i := 0; i <= r.w; i++ {
			// stdscr.MoveAddChar(r.y+r.h, r.x+i, gc.ACS_HLINE)
			renderer.RenderQueue <- render.PositionedChar{
				Rune: '─',
				Cursor: render.Cursor{
					X:     r.x + i,
					Y:     r.y + r.h,
					Style: style,
				},
			}
		}
	}

	// draw corners
	if topBorder && leftBorder {
		// stdscr.MoveAddChar(r.y-1, r.x-1, gc.ACS_ULCORNER)
		renderer.RenderQueue <- render.PositionedChar{
			Rune: '┌',
			Cursor: render.Cursor{
				X:     r.x - 1,
				Y:     r.y - 1,
				Style: style,
			},
		}
	}
	if topBorder && rightBorder {
		// stdscr.MoveAddChar(r.y-1, r.x+r.w, gc.ACS_URCORNER)
		renderer.RenderQueue <- render.PositionedChar{
			Rune: '┐',
			Cursor: render.Cursor{
				X:     r.x + r.w,
				Y:     r.y - 1,
				Style: style,
			},
		}
	}
	if bottomBorder && leftBorder {
		// stdscr.MoveAddChar(r.y+r.h, r.x-1, gc.ACS_LLCORNER)
		renderer.RenderQueue <- render.PositionedChar{
			Rune: '└',
			Cursor: render.Cursor{
				X:     r.x - 1,
				Y:     r.y + r.h,
				Style: style,
			},
		}
	}
	if bottomBorder && rightBorder {
		// stdscr.MoveAddChar(r.y+r.h, r.y+r.w, gc.ACS_LRCORNER)
		renderer.RenderQueue <- render.PositionedChar{
			Rune: '┘',
			Cursor: render.Cursor{
				X:     r.x + r.w,
				Y:     r.y + r.h,
				Style: style,
			},
		}
	}

	// stdscr.Refresh()
	// renderer.Refresh()
}

// getTermSize returns the wusth
func getTermSize() (int, int, error) {
	cmd := exec.Command("stty", "size")
	cmd.Stdin = os.Stdin
	out, err := cmd.Output()
	if err != nil {
		return 0, 0, err
	}

	outStr := strings.TrimSpace(string(out))
	parts := strings.Split(outStr, " ")

	h, err := strconv.ParseInt(parts[0], 10, 64)
	if err != nil {
		return 0, 0, err
	}
	w, err := strconv.ParseInt(parts[1], 10, 64)
	if err != nil {
		return 0, 0, err
	}

	wInt := int(int64(w))
	hInt := int(int64(h))
	return wInt, hInt, nil
}
package main

import (
	"fmt"
	"log"
)

// Direction is the type of Up, Down, Left, and Right
type Direction int

// directions
const (
	_ Direction = iota
	Up
	Down
	Left
	Right
)

// A Path is a series of indicies leading from the root to a Container
type Path []int

func getSelection() Path {
	path := Path{root.selectionIdx}
	selection := root.elements[root.selectionIdx].contents

	for {
		switch val := selection.(type) {
		case *Pane:
			return path
		case *Split:
			path = append(path, val.selectionIdx)
			selection = val.elements[val.selectionIdx].contents
		default:
			panic(fmt.Sprintf("Unexpected type %T", selection))
		}
	}
}

func moveWindow(d Direction) {
	path := getSelection()
	parent, parentPath := path.getParent()

	vert := parent.verticallyStacked

	if (!vert && d == Left) || (vert && d == Up) {
		idx := parent.selectionIdx

		if idx == 0 {
			return
		}

		tmp := parent.elements[idx-1]
		parent.elements[idx-1] = parent.elements[idx]
		parent.elements[idx] = tmp

		parent.selectionIdx--

		// root.refreshRenderRect()
	} else if (!vert && d == Right) || (vert && d == Down) {
		idx := parent.selectionIdx

		if idx == len(parent.elements)-1 {
			return
		}

		tmp := parent.elements[idx+1]
		parent.elements[idx+1] = parent.elements[idx]
		parent.elements[idx] = tmp

		parent.selectionIdx++

		// root.refreshRenderRect()
	} else {
		movingVert := d == Up || d == Down

		p := path
		for len(p) > 0 {
			s, _ := p.getParent()
			if s.verticallyStacked == movingVert {
				tmp := parentPath.popContainer((*parent).selectionIdx)

				if d == Left || d == Up {
					s.insertContainer(tmp, s.selectionIdx)
					s.selectionIdx--
				} else {
					s.insertContainer(tmp, s.selectionIdx+1)
					s.selectionIdx++
				}

				// root.refreshRenderRect()
				break
			}
			p = p[:len(p)-1]
		}

		if len(p) == 0 {
			tmp := parentPath.popContainer(parent.selectionIdx)
			tmpRoot := root

			var h int
			if config.statusBar {
				h = termH - 1
			} else {
				h = termH
			}

			root = Split{
				renderRect:        Rect{w: termW, h: h},
				verticallyStacked: movingVert,
				selectionIdx:      0,
				elements: []Node{
					Node{
						size:     1,
						contents: &tmpRoot,
					},
				},
			}

			insertIdx := 0
			if d == Down || d == Right {
				insertIdx = 1
			}
			root.insertContainer(tmp, insertIdx)
			root.selectionIdx = insertIdx

			// root.refreshRenderRect()
		}
	}

	// root.refreshRenderRect()
}

func killWindow() {
	parent, parentPath := getSelection().getParent()
	t := parentPath.popContainer(parent.selectionIdx)
	t.(*Pane).kill()
}

func (s *Split) kill() {
	for _, n := range s.elements {
		n.contents.kill()
	}
}

func (p Path) popContainer(idx int) Container {
	s := p.getContainer().(*Split)

	tmp := s.elements[idx]

	s.elements = append(s.elements[:idx], s.elements[idx+1:]...)

	// resize nodes
	scaleFactor := float32(1.0 / (1.0 - tmp.size))
	for i := range s.elements {
		s.elements[i].size *= scaleFactor
	}

	if idx > len(s.elements)-1 {
		s.selectionIdx--
	}

	if len(s.elements) == 1 && len(p) >= 1 {
		switch val := (*s).elements[0].contents.(type) {
		case *Pane:
			parent, _ := p.getParent()
			parent.elements[p[len(p)-1]].contents = val
		case *Split:
			s.verticallyStacked = val.verticallyStacked
			s.elements = val.elements
			s.selectionIdx = val.selectionIdx
		}
	}

	return tmp.contents
}

// stuff like h(h(x), y) -> h(x, y)
func (s *Split) simplify() {
	if len(s.elements) == 1 {
		switch child := (*s).elements[0].contents.(type) {
		case *Split:
			s.verticallyStacked = child.verticallyStacked
			s.elements = child.elements
			s.selectionIdx = child.selectionIdx
		}
	} else {
		newElements := []Node{}
		selectionIdx := (*s).selectionIdx
		for idx, n := range (*s).elements {
			switch child := n.contents.(type) {
			case *Split:
				if child.verticallyStacked == s.verticallyStacked {
					for j := range child.elements {
						child.elements[j].size *= n.size
					}
					newElements = append(newElements, child.elements...)
					if idx == s.selectionIdx {
						selectionIdx += child.selectionIdx
					} else if idx < s.selectionIdx {
						selectionIdx += len(child.elements) - 1
					}
				} else {
					newElements = append(newElements, n)
				}
			case *Pane:
				newElements = append(newElements, n)
			}
		}
		s.elements = newElements
		s.selectionIdx = selectionIdx
	}

	for _, n := range s.elements {
		switch child := n.contents.(type) {
		case *Split:
			child.simplify()
		}
	}
}

func (s *Split) insertContainer(c Container, idx int) {
	newNodeSize := float32(1) / float32(len(s.elements)+1)

	// resize siblings
	scaleFactor := float32(1) - newNodeSize
	for i := range s.elements {
		s.elements[i].size *= scaleFactor
	}

	newNode := Node{
		size:     newNodeSize,
		contents: c,
	}
	s.elements = append(s.elements[:idx], append([]Node{newNode}, s.elements[idx:]...)...)
}

func moveSelection(d Direction) {
	path := getSelection()

	// deselect the old Term
	oldTerm := path.getContainer().(*Pane)
	oldTerm.selected = false
	oldTerm.softRefresh()

	parent, _ := path.getParent()

	vert := parent.verticallyStacked

	if (d == Left && !vert) || (d == Up && vert) {
		parent.selectionIdx--
		if parent.selectionIdx < 0 {
			parent.selectionIdx = 0
		}
	} else if (d == Right && !vert) || (d == Down && vert) {
		parent.selectionIdx++
		if parent.selectionIdx > len(parent.elements)-1 {
			parent.selectionIdx = len(parent.elements) - 1
		}
	} else {
		movingVert := d == Up || d == Down

		p := path
		for len(p) > 0 {
			s, _ := p.getParent()
			if s.verticallyStacked == movingVert {
				if d == Up || d == Left {
					s.selectionIdx--
					if s.selectionIdx < 0 {
						s.selectionIdx = 0
					}
				} else {
					s.selectionIdx++
					if s.selectionIdx > len(s.elements)-1 {
						s.selectionIdx = len(s.elements) - 1
					}
				}
				break
			}
			p = p[:len(p)-1]
		}
	}

	// deselect the old Term
	nowTerm := getSelection().getContainer().(*Pane)
	nowTerm.selected = true
	nowTerm.softRefresh()
	nowTerm.vterm.RefreshCursor()
}

func newWindow() {
	path := getSelection()

	// deselect the old Term
	oldTerm := path.getContainer().(*Pane)
	oldTerm.selected = false
	// the parent is going to be redrawn so we don't need to redraw the old term right now

	parent, _ := path.getParent()

	size := float32(1) / float32(len(parent.elements)+1)

	// resize siblings
	scaleFactor := float32(1) - size
	for i := range parent.elements {
		parent.elements[i].size *= scaleFactor
	}

	// add new child
	createdTerm := newTerm(true)
	parent.elements = append(parent.elements, Node{
		size:     size,
		contents: createdTerm,
	})

	// update selection to new child
	parent.selectionIdx = len(parent.elements) - 1
	parent.refreshRenderRect()
}

func (p Path) getParent() (*Split, Path) {
	parentPath := p[:len(p)-1]
	return parentPath.getContainer().(*Split), parentPath
}

func (p Path) getContainer() Container {
	if len(p) == 0 {
		return &root
	}

	cur := root.elements[p[0]].contents
	p = p[1:]
	for len(p) > 0 {
		switch val := cur.(type) {
		case *Split:
			cur = val.elements[val.selectionIdx].contents
			p = p[1:]
		default:
			log.Fatal("bad path")
		}
	}

	return cur
}

func $ getPanes() []*Pane {
	return getPanesOfSplit(&root)
}

func getPanesOfSplit(s *Split) []*Pane {
	panes := []*Pane{}
	for _, e := range s.elements {
		switch c := e.contents.(type) {
		case *Split:
			panes = append(panes, getPanesOfSplit(c)...)
		case *Pane:
			panes = append(panes, c)
		}
	}
@
	return panes
}
~

